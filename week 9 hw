int nbSamples = 1200;
float [] [] ptsCircle = new float [nbSamples] [2];
float radius = 200.0, deltaX;
int idVertexStart, idVertexEnd, deltaIndex, idVertexStartInsideCrescent, idVertexEndInsideCrescent;
 
void setup() {
  size(600, 600);
  background(0);
  noStroke();
 
  for (int i=0; i<nbSamples; i++) {
    ptsCircle[i][0] = radius * (cos(TWO_PI*(i/float(nbSamples))));
    ptsCircle[i][1] = radius * (sin(TWO_PI*(i/float(nbSamples))));
  }
}
 
void draw() {
  background(0);
  translate(width*0.5, height*0.5);
  rotate(HALF_PI+QUARTER_PI);
 
  idVertexStart = -floor(map(mouseX,0,width*2,floor(nbSamples*0.5),0));
  idVertexEnd = floor(map(mouseX,0,width*2,floor(nbSamples*0.5),0));
  deltaIndex = idVertexEnd-idVertexStart;
  idVertexStartInsideCrescent = -floor((nbSamples-deltaIndex)*0.5);
  idVertexEndInsideCrescent = floor((nbSamples-deltaIndex)*0.5);
 
 
  fill(255);
  beginShape();
 
  // Outside crescent
  for (int i=idVertexStart; i<idVertexEnd; i++) {
   if (i < 0) {
     vertex(ptsCircle[nbSamples+i][0], ptsCircle[nbSamples+i][1]);
   } else {
     vertex(ptsCircle[i][0], ptsCircle[i][1]);
   }
  }
  if (deltaIndex < nbSamples) {
   vertex(ptsCircle[idVertexEnd][0], ptsCircle[idVertexEnd][1]);
  }
 
  // to manage the translation of inside crescent
  if (deltaIndex > floor(nbSamples*0.5)) {
    int nbIndexDelta = deltaIndex-floor(nbSamples*0.5);
    for (int i = 0; i < nbIndexDelta; i++) {
      deltaX+= ptsCircle[(nbSamples+idVertexStart)+i][0];
    }
  }
 
  // Inside crescent
  for (int i=idVertexEndInsideCrescent; i>idVertexStartInsideCrescent; i--) {
   if (i < 0) {
     vertex(ptsCircle[nbSamples+i][0]+(deltaX*2), ptsCircle[nbSamples+i][1]);
   } else {
     vertex(ptsCircle[i][0]+(deltaX*2), ptsCircle[i][1]);
   }
  }
  endShape(CLOSE);
 
  deltaX = 0;
}
